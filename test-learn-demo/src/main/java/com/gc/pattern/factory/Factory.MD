1.简单工厂模式(Simple Factory Pattern):
> 是指由一个工厂对象决定创建出哪一种产品类的实例

`属于创建型模式,但它不属于GOF,23种设计模式`

适用场景:
工厂类负责创建的对象较少.客户端只需要传入工厂类的参数,对于如何创建对象的逻辑不需要关注.

优点:
- 只需要传入一个正确的参数,就可以获取所需要的对象,无须知道细节

缺点:
- 工厂类的职责过重,增加新的产品的时候需要修改代码,违背开闭原则;不易于拓展负责的产品,产品过多时,逻辑会过于复杂.

2.工厂方法模式(Factory Method Pattern):
> 是指定义一个创建对象的接口,让实现这个接口的类来决定实例化哪个类,工厂方法让类的实例化推迟到子类中进行

`属于创建型模式`

适用场景:
- 客户只需要知道创建产品的工产名,而不需要知道具体的产品名
- 创建对象需要大量的重复代码
- 客户端不依赖于产品类如何被创建,实现等细节.一个类通过其子类来指定创建哪个产品

优点:
- 只需要关注创建产品的工厂,不需要关注创建产品的细节
- 加入新的产品符合开闭原则

缺点:
- 类的个数容易过多,增加代码的复杂度和可读性.
- 增加了系统的抽象性和可读性

3.抽象工厂模式(Abstract Factory Pattern):
> 是指提供一个创建一系列相关或者相互依赖对象的接口,无须指定他们具体的类.

`创建型模式`

适用场景:
- 客户端不依赖产品类实例如何被创建,实现等细节
- 一系列相关的产品对象(属于同一产品族)一起使用创建需要大量代码时
- 提供一个产品类的库,所有的产品以一个接口出现,客户端不用依赖于具体的实现.

优点:
- 具体产品在应用代码层隔离,无须关心创建细节
- 将一个系列的产品族统一到一起创建,新增一个新的产品族(已经定义在需要创建的产品族中了)的时候只需新增一个具体的工厂,符合开闭原则

缺点:
- 规定了所有可能被创建产品的集合,要拓展新的产品(在需要创建的产品族中没有事先定义好)困难,需要修改抽象的接口,不符合开闭原则
- 增加了系统的抽象性和复杂度
